# 08장: Promise와 비동기 처리

## 8-1. 비동기 처리의 이해

### 8-1-1. 동기 vs 비동기

**동기(Synchronous) 처리**는 코드가 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업이 대기합니다.

```javascript
console.log('첫 번째');
console.log('두 번째'); 
console.log('세 번째');
// 출력: 첫 번째 → 두 번째 → 세 번째
```

**비동기(Asynchronous) 처리**는 특정 작업이 완료되기를 기다리지 않고 다음 코드를 실행합니다.

```javascript
console.log('첫 번째');
setTimeout(function() {
    console.log('두 번째');
}, 1000);
console.log('세 번째');
// 출력: 첫 번째 → 세 번째 → 두 번째 (1초 후)
```

### 8-1-2. 자바스크립트의 싱글 스레드와 이벤트 루프

자바스크립트는 **싱글 스레드** 언어입니다. 한 번에 하나의 작업만 처리할 수 있습니다. 하지만 **이벤트 루프(Event Loop)**와 **콜백 큐(Callback Queue)**를 통해 비동기 작업을 처리할 수 있습니다.

**실행 구조:**

1. **콜 스택(Call Stack)**: 현재 실행 중인 함수
2. **Web APIs**: 타이머, HTTP 요청 등 브라우저가 제공하는 비동기 API
3. **콜백 큐(Callback Queue)**: 비동기 작업 완료 후 실행될 콜백 함수 대기
4. **이벤트 루프**: 콜 스택이 비면 콜백 큐의 함수를 콜 스택으로 이동

```javascript
console.log('시작');

setTimeout(function() {
    console.log('타이머 완료');
}, 0);

console.log('끝');

// 출력: 시작 → 끝 → 타이머 완료
// setTimeout의 콜백은 콜 스택이 비어야 실행됨
```

### 8-1-3. 콜백 패턴의 한계 (콜백 헬)

비동기 작업을 처리하기 위해 전통적으로 콜백 함수를 사용했습니다. 하지만 여러 비동기 작업이 중첩되면 **콜백 헬(Callback Hell)**이 발생합니다.

```javascript
// 콜백 헬 예시
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                getMoreData(d, function(e) {
                    console.log('최종 결과:', e);
                });
            });
        });
    });
});
```

**콜백 헬의 문제점:**

- 가독성이 매우 낮음 (피라미드 구조)
- 에러 처리가 어려움
- 코드 유지보수가 힘듦
- 디버깅이 어려움

---

## 8-2. Promise 기초

### 8-2-1. Promise란 무엇인가

**Promise**는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다. 콜백 헬을 해결하고 비동기 코드를 더 깔끔하게 작성할 수 있게 해줍니다.

**Promise의 특징:**

- 비동기 작업의 최종 결과를 담는 그릇
- 작업의 성공(resolve) 또는 실패(reject)를 명확히 구분
- 체이닝을 통한 순차적 비동기 처리 지원
- 한 번 결정된 상태는 변경되지 않음

### 8-2-2. Promise의 3가지 상태

Promise는 다음 3가지 상태 중 하나를 가집니다:

1. **Pending (대기)**: 초기 상태, 작업이 진행 중
2. **Fulfilled (이행)**: 작업이 성공적으로 완료됨
3. **Rejected (거부)**: 작업이 실패함

```javascript
// Pending 상태
var promise = new Promise(function(resolve, reject) {
    // 비동기 작업 수행
});

// Fulfilled 상태로 전환
var promise = new Promise(function(resolve, reject) {
    resolve('성공!');
});

// Rejected 상태로 전환
var promise = new Promise(function(resolve, reject) {
    reject('실패!');
});
```

### 8-2-3. Promise 생성과 기본 사용법

Promise는 `new Promise()` 생성자를 통해 생성하며, 실행 함수(executor)를 인자로 받습니다.

```javascript
var promise = new Promise(function(resolve, reject) {
    // 비동기 작업
    var success = true;

    if (success) {
        resolve('작업 성공');  // 성공 시
    } else {
        reject('작업 실패');   // 실패 시
    }
});
```

**실행 함수의 매개변수:**

- `resolve`: 작업 성공 시 호출하는 함수
- `reject`: 작업 실패 시 호출하는 함수

### 8-2-4. then, catch, finally 메서드

Promise는 결과를 처리하기 위한 3가지 메서드를 제공합니다:

**then() - 성공 처리**

```javascript
promise.then(function(result) {
    console.log(result);  // '작업 성공'
});
```

**catch() - 실패 처리**

```javascript
promise.catch(function(error) {
    console.error(error);  // '작업 실패'
});
```

**finally() - 항상 실행**

```javascript
promise.finally(function() {
    console.log('작업 완료 (성공/실패 무관)');
});
```

**전체 예시:**

```javascript
var promise = new Promise(function(resolve, reject) {
    setTimeout(function() {
        resolve('데이터 로드 완료');
    }, 1000);
});

promise
    .then(function(result) {
        console.log(result);  // 성공 시
    })
    .catch(function(error) {
        console.error(error);  // 실패 시
    })
    .finally(function() {
        console.log('정리 작업');  // 항상 실행
    });
```

---

## 8-3. Promise 체이닝

### 8-3-1. 체이닝의 개념과 장점

Promise의 `then()` 메서드는 새로운 Promise를 반환하므로, 여러 비동기 작업을 **체이닝(연결)**할 수 있습니다.

```javascript
fetchUser()
    .then(function(user) {
        return fetchPosts(user.id);
    })
    .then(function(posts) {
        return fetchComments(posts[0].id);
    })
    .then(function(comments) {
        console.log(comments);
    });
```

**장점:**

- 콜백 헬 해결
- 코드의 가독성 향상
- 에러 처리 간소화
- 순차적 비동기 흐름 제어 가능

### 8-3-2. 반환값 전달하기

`then()` 콜백에서 반환한 값은 다음 `then()`의 인자로 전달됩니다.

```javascript
Promise.resolve(1)
    .then(function(num) {
        console.log(num);  // 1
        return num + 10;
    })
    .then(function(num) {
        console.log(num);  // 11
        return num + 100;
    })
    .then(function(num) {
        console.log(num);  // 111
    });
```

**Promise를 반환하는 경우:**

```javascript
function delay(ms) {
    return new Promise(function(resolve) {
        setTimeout(resolve, ms);
    });
}

Promise.resolve('시작')
    .then(function(msg) {
        console.log(msg);  // '시작'
        return delay(1000);  // Promise 반환
    })
    .then(function() {
        console.log('1초 후');  // 1초 후 실행
        return delay(1000);
    })
    .then(function() {
        console.log('2초 후');
    });
```

### 8-3-3. 에러 전파와 처리

체이닝 중 에러가 발생하면 가장 가까운 `catch()`로 전파됩니다.

```javascript
Promise.resolve()
    .then(function() {
        throw new Error('에러 발생!');
    })
    .then(function() {
        console.log('실행 안됨');
    })
    .catch(function(error) {
        console.error('에러 잡음:', error.message);  // '에러 잡음: 에러 발생!'
    });
```

**중간에서 에러 복구하기:**

```javascript
Promise.reject('실패')
    .catch(function(error) {
        console.log('에러 처리:', error);
        return '복구됨';  // 새로운 값 반환
    })
    .then(function(result) {
        console.log(result);  // '복구됨'
    });
```

### 8-3-4. 체이닝 vs 콜백 헬 비교

**콜백 헬:**

```javascript
getUser(function(user) {
    getPosts(user.id, function(posts) {
        getComments(posts[0].id, function(comments) {
            console.log(comments);
        });
    });
});
```

**Promise 체이닝:**

```javascript
getUser()
    .then(function(user) {
        return getPosts(user.id);
    })
    .then(function(posts) {
        return getComments(posts[0].id);
    })
    .then(function(comments) {
        console.log(comments);
    })
    .catch(function(error) {
        console.error(error);
    });
```

---

## 8-4. Promise 정적 메서드

### 8-4-1. Promise.resolve() / Promise.reject()

즉시 이행되거나 거부되는 Promise를 생성합니다.

```javascript
// 즉시 이행
Promise.resolve('성공').then(function(result) {
    console.log(result);  // '성공'
});

// 즉시 거부
Promise.reject('실패').catch(function(error) {
    console.error(error);  // '실패'
});
```

**사용 예시:**

```javascript
function getUserData(useCache) {
    if (useCache) {
        return Promise.resolve(cachedData);  // 캐시 데이터 즉시 반환
    }
    return fetch('/api/user');  // API 호출
}
```

### 8-4-2. Promise.all() - 병렬 처리

여러 Promise를 **병렬**로 실행하고, 모두 완료될 때까지 기다립니다.

```javascript
var promise1 = Promise.resolve(3);
var promise2 = 42;
var promise3 = new Promise(function(resolve) {
    setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3])
    .then(function(results) {
        console.log(results);  // [3, 42, 'foo']
    });
```

**주의사항:**

- **하나라도 실패하면 전체 실패**
- 모든 결과가 배열로 반환됨
- 순서는 입력 순서대로 유지됨

```javascript
Promise.all([
    Promise.resolve(1),
    Promise.reject('에러!'),
    Promise.resolve(3)
])
.catch(function(error) {
    console.error(error);  // '에러!' (즉시 실패)
});
```

### 8-4-3. Promise.race() - 경쟁 처리

여러 Promise 중 **가장 먼저 완료되는 것**의 결과를 반환합니다.

```javascript
var promise1 = new Promise(function(resolve) {
    setTimeout(resolve, 500, '느림');
});

var promise2 = new Promise(function(resolve) {
    setTimeout(resolve, 100, '빠름');
});

Promise.race([promise1, promise2])
    .then(function(result) {
        console.log(result);  // '빠름' (100ms 후)
    });
```

**타임아웃 구현 예시:**

```javascript
function timeout(ms) {
    return new Promise(function(_, reject) {
        setTimeout(function() {
            reject(new Error('타임아웃!'));
        }, ms);
    });
}

Promise.race([
    fetch('/api/data'),
    timeout(5000)  // 5초 타임아웃
])
.then(function(data) {
    console.log('데이터 로드 성공');
})
.catch(function(error) {
    console.error('5초 안에 완료 안됨');
});
```

### 8-4-4. Promise.allSettled() - 모든 결과 수집

**ES2020**에서 추가된 메서드로, 모든 Promise의 성공/실패 여부와 관계없이 **모든 결과**를 수집합니다.

```javascript
Promise.allSettled([
    Promise.resolve(1),
    Promise.reject('에러'),
    Promise.resolve(3)
])
.then(function(results) {
    console.log(results);
    // [
    //   { status: 'fulfilled', value: 1 },
    //   { status: 'rejected', reason: '에러' },
    //   { status: 'fulfilled', value: 3 }
    // ]
});
```

**Promise.all()과의 차이:**

- `Promise.all()`: 하나라도 실패하면 즉시 실패
- `Promise.allSettled()`: 모든 Promise가 완료될 때까지 기다림

### 8-4-5. Promise.any() - 첫 성공 대기

**ES2021**에서 추가된 메서드로, **가장 먼저 성공하는 Promise**의 결과를 반환합니다.

```javascript
Promise.any([
    Promise.reject('에러1'),
    Promise.resolve('성공!'),
    Promise.reject('에러2')
])
.then(function(result) {
    console.log(result);  // '성공!'
});
```

**모두 실패하는 경우:**

```javascript
Promise.any([
    Promise.reject('에러1'),
    Promise.reject('에러2')
])
.catch(function(error) {
    console.error(error);  // AggregateError: All promises were rejected
});
```

---

## 8-5. 실전 패턴과 주의사항

### 8-5-1. 에러 처리 베스트 프랙티스

**1. 항상 catch() 추가하기**

```javascript
// ❌ 나쁜 예: catch 누락
fetchData()
    .then(function(data) {
        console.log(data);
    });

// ✅ 좋은 예: catch 추가
fetchData()
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.error('에러 발생:', error);
    });
```

**2. 체이닝 끝에 catch() 배치**

```javascript
fetchUser()
    .then(fetchPosts)
    .then(fetchComments)
    .catch(function(error) {
        // 모든 단계의 에러를 여기서 처리
        console.error('처리 실패:', error);
    });
```

**3. 특정 에러만 처리하기**

```javascript
fetchData()
    .catch(function(error) {
        if (error.name === 'NetworkError') {
            return fetchDataFromCache();  // 네트워크 에러만 복구
        }
        throw error;  // 다른 에러는 재전파
    })
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.error('복구 불가:', error);
    });
```

### 8-5-2. Promise와 try-catch

**Promise 내부의 동기 에러는 자동으로 catch됨:**

```javascript
new Promise(function(resolve, reject) {
    throw new Error('에러!');  // reject('에러!')와 동일
})
.catch(function(error) {
    console.error(error);  // 에러 잡힘
});
```

**하지만 비동기 콜백 내부는 try-catch 필요:**

```javascript
new Promise(function(resolve, reject) {
    setTimeout(function() {
        try {
            var result = JSON.parse('잘못된 JSON');
            resolve(result);
        } catch (error) {
            reject(error);  // 명시적으로 reject 호출
        }
    }, 100);
});
```

### 8-5-3. 중첩된 Promise 피하기

**❌ 나쁜 예: Promise 중첩**

```javascript
fetchUser()
    .then(function(user) {
        fetchPosts(user.id)
            .then(function(posts) {
                fetchComments(posts[0].id)
                    .then(function(comments) {
                        console.log(comments);
                    });
            });
    });
```

**✅ 좋은 예: 평탄한 체이닝**

```javascript
fetchUser()
    .then(function(user) {
        return fetchPosts(user.id);
    })
    .then(function(posts) {
        return fetchComments(posts[0].id);
    })
    .then(function(comments) {
        console.log(comments);
    });
```

### 8-5-4. 동기 코드와 비동기 코드 혼용 시 주의점

**1. then() 안에서 값을 반환하지 않으면 undefined 전달**

```javascript
// ❌ 나쁜 예
Promise.resolve(1)
    .then(function(num) {
        num + 10;  // 반환 누락!
    })
    .then(function(result) {
        console.log(result);  // undefined
    });

// ✅ 좋은 예
Promise.resolve(1)
    .then(function(num) {
        return num + 10;  // 명시적 반환
    })
    .then(function(result) {
        console.log(result);  // 11
    });
```

**2. Promise가 아닌 값도 then()으로 전달 가능**

```javascript
Promise.resolve(1)
    .then(function(num) {
        return num + 10;  // 일반 값 반환
    })
    .then(function(num) {
        return Promise.resolve(num + 100);  // Promise 반환
    })
    .then(function(num) {
        console.log(num);  // 111 (자동 언래핑)
    });
```

### 8-5-5. Promise 안티 패턴

**1. Promise 생성자 남용 (불필요한 wrapping)**

```javascript
// ❌ 나쁜 예
function fetchData() {
    return new Promise(function(resolve, reject) {
        fetch('/api/data')
            .then(function(data) {
                resolve(data);
            })
            .catch(function(error) {
                reject(error);
            });
    });
}

// ✅ 좋은 예: fetch는 이미 Promise 반환
function fetchData() {
    return fetch('/api/data');
}
```

**2. catch 없이 then만 사용**

```javascript
// ❌ 나쁜 예: 에러 처리 누락
fetchData().then(function(data) {
    console.log(data);
});

// ✅ 좋은 예
fetchData()
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.error(error);
    });
```

**3. forEach와 Promise 혼용**

```javascript
// ❌ 나쁜 예: forEach는 Promise를 기다리지 않음
var promises = [];
[1, 2, 3].forEach(function(id) {
    promises.push(fetchUser(id));
});

// ✅ 좋은 예: Promise.all 사용
var promises = [1, 2, 3].map(function(id) {
    return fetchUser(id);
});
Promise.all(promises).then(function(users) {
    console.log(users);
});
```

---

## 8-6. async/await (선택적)

### 8-6-1. async/await 기본 문법

**ES2017**에서 추가된 `async/await`는 Promise를 더 동기 코드처럼 작성할 수 있게 해줍니다.

**async 함수:**

```javascript
async function fetchData() {
    return '데이터';  // Promise.resolve('데이터')와 동일
}

fetchData().then(function(data) {
    console.log(data);  // '데이터'
});
```

**await 키워드:**

```javascript
async function fetchUser() {
    var user = await fetch('/api/user');  // Promise 완료 대기
    console.log(user);
    return user;
}
```

### 8-6-2. Promise와의 관계

`async/await`는 Promise의 **문법적 설탕(Syntactic Sugar)**입니다.

**Promise 체이닝:**

```javascript
function fetchUserData() {
    return fetchUser()
        .then(function(user) {
            return fetchPosts(user.id);
        })
        .then(function(posts) {
            return fetchComments(posts[0].id);
        });
}
```

**async/await 버전:**

```javascript
async function fetchUserData() {
    var user = await fetchUser();
    var posts = await fetchPosts(user.id);
    var comments = await fetchComments(posts[0].id);
    return comments;
}
```

### 8-6-3. 에러 처리

`async/await`에서는 `try-catch`를 사용해 에러를 처리합니다.

```javascript
async function fetchData() {
    try {
        var data = await fetch('/api/data');
        console.log(data);
    } catch (error) {
        console.error('에러 발생:', error);
    }
}
```

**여러 단계의 에러 처리:**

```javascript
async function processData() {
    try {
        var user = await fetchUser();
        var posts = await fetchPosts(user.id);
        var comments = await fetchComments(posts[0].id);
        return comments;
    } catch (error) {
        console.error('처리 실패:', error);
        throw error;  // 상위로 전파
    }
}
```

### 8-6-4. 병렬 처리 패턴

**순차 실행 (느림):**

```javascript
async function fetchData() {
    var user = await fetchUser();    // 1초
    var posts = await fetchPosts();  // 1초
    return { user, posts };          // 총 2초
}
```

**병렬 실행 (빠름):**

```javascript
async function fetchData() {
    var userPromise = fetchUser();    // 즉시 시작
    var postsPromise = fetchPosts();  // 즉시 시작

    var user = await userPromise;     // 1초
    var posts = await postsPromise;   // 추가 대기 없음
    return { user, posts };           // 총 1초
}
```

**Promise.all 사용:**

```javascript
async function fetchData() {
    var [user, posts] = await Promise.all([
        fetchUser(),
        fetchPosts()
    ]);
    return { user, posts };  // 총 1초
}
```

---

## 학습 정리

### 핵심 개념

1. **Promise**: 비동기 작업의 성공/실패를 나타내는 객체
2. **3가지 상태**: Pending → Fulfilled 또는 Rejected
3. **체이닝**: then()을 연결하여 순차적 비동기 처리
4. **정적 메서드**: all, race, allSettled, any로 여러 Promise 관리
5. **async/await**: Promise를 동기 코드처럼 작성하는 문법

### Promise를 사용해야 하는 이유

- 콜백 헬 해결
- 명확한 에러 처리
- 코드 가독성 향상
- 비동기 흐름 제어 용이

### 다음 단계

- 실전 예제 코드 실습 (`promise/` 디렉토리)
- fetch API와 Promise 활용
- async/await 실무 패턴 학습
